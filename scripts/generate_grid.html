<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¹å®«æ ¼åˆ‡å›¾å™¨</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #0a0a0a;
            color: #00d9ff;
            padding: 20px;
            text-align: center;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        canvas {
            border: 2px solid #00d9ff;
            margin: 20px 0;
            background: #0a0a0a;
            box-shadow: 0 0 20px rgba(0, 217, 255, 0.5);
        }
        button {
            background: #00d9ff;
            color: #0a0a0a;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
            border-radius: 4px;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover {
            background: #00ff88;
            box-shadow: 0 0 20px #00ff88;
            transform: translateY(-2px);
        }
        .info {
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 217, 255, 0.1);
            border: 1px solid #00d9ff;
            border-radius: 4px;
        }
        input[type="file"] {
            display: none;
        }
        .file-upload-label {
            display: inline-block;
            background: #00d9ff;
            color: #0a0a0a;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
            border-radius: 4px;
            font-weight: bold;
            transition: all 0.3s;
        }
        .file-upload-label:hover {
            background: #00ff88;
            box-shadow: 0 0 20px #00ff88;
            transform: translateY(-2px);
        }
        h1 {
            text-shadow: 0 0 10px #00d9ff, 0 0 20px #00d9ff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ“± ä¹å®«æ ¼åˆ‡å›¾å™¨</h1>
        <div class="info">
            <p>æ‚¨å¯ä»¥ä¸Šä¼ è‡ªå·±çš„å›¾ç‰‡ï¼Œæˆ–è€…ç‚¹å‡»"éšæœºç”Ÿæˆ"æŒ‰é’®ç”Ÿæˆéšæœºå›¾ç‰‡ï¼Œç„¶åç‚¹å‡»"åˆ‡åˆ†å¹¶ä¸‹è½½"æŒ‰é’®å°†å…¶åˆ‡åˆ†æˆ9éƒ¨åˆ†ã€‚</p>
            <p>åˆ‡åˆ†åçš„å›¾ç‰‡å°†è‡ªåŠ¨ä¸‹è½½åˆ°æ‚¨çš„ä¸‹è½½æ–‡ä»¶å¤¹ã€‚</p>
        </div>
        
        <canvas id="mainCanvas" width="600" height="600"></canvas>
        
        <div>
            <label for="imageUpload" class="file-upload-label">ä¸Šä¼ å›¾ç‰‡</label>
            <input type="file" id="imageUpload" accept="image/*" onchange="handleImageUpload(event)">
            <button onclick="generateImage()">éšæœºç”Ÿæˆ</button>
            <button onclick="splitAndDownload()">åˆ‡åˆ†å¹¶ä¸‹è½½</button>
        </div>
        
        <div id="status"></div>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        
        // èµ›åšæœ‹å…‹é…è‰²æ–¹æ¡ˆ
        const cyberColors = [
            '#00d9ff', // é’è‰²
            '#ff00ff', // ç²‰è‰²
            '#9d00ff', // ç´«è‰²
            '#00ff88', // ç»¿è‰²
            '#ffd700', // é‡‘è‰²
            '#00ffff', // å¤©è“è‰²
            '#ff0080', // æ·±ç²‰è‰²
            '#8000ff'  // æ·±ç´«è‰²
        ];
        
        // ç”Ÿæˆéšæœºé¢œè‰²ï¼ˆä»èµ›åšæœ‹å…‹é…è‰²ä¸­ï¼‰
        function randomCyberColor() {
            return cyberColors[Math.floor(Math.random() * cyberColors.length)];
        }
        
        // ç”Ÿæˆéšæœºæ•´æ•°
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        // ç”Ÿæˆéšæœºæµ®ç‚¹æ•°
        function randomFloat(min, max) {
            return Math.random() * (max - min) + min;
        }
        
        function generateImage() {
            const size = 600;
            
            // æ¸…ç©ºç”»å¸ƒï¼Œä½¿ç”¨æ·±è‰²èƒŒæ™¯
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, size, size);
            
            // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
            ctx.strokeStyle = '#00d9ff';
            ctx.lineWidth = 0.5;
            ctx.globalAlpha = 0.3;
            const gridSize = 30;
            for (let x = 0; x <= size; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, size);
                ctx.stroke();
            }
            for (let y = 0; y <= size; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(size, y);
                ctx.stroke();
            }
            ctx.globalAlpha = 1.0;
            
            // ç”Ÿæˆéœ“è™¹åœ†åœˆ
            const circleCount = randomInt(3, 8);
            for (let i = 0; i < circleCount; i++) {
                const x = randomInt(50, size - 50);
                const y = randomInt(50, size - 50);
                const radius = randomInt(30, 100);
                const color = randomCyberColor();
                
                // å¤–å‘å…‰æ•ˆæœ
                for (let offset = 0; offset < 15; offset += 3) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.3 - offset * 0.02;
                    ctx.beginPath();
                    ctx.arc(x, y, radius + offset, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // ä¸»åœ†åœˆ
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.globalAlpha = 1.0;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // ç”Ÿæˆéœ“è™¹çº¿æ¡ç½‘ç»œ
            const lineCount = randomInt(8, 15);
            for (let i = 0; i < lineCount; i++) {
                const color = randomCyberColor();
                ctx.strokeStyle = color;
                ctx.lineWidth = randomInt(1, 3);
                ctx.globalAlpha = randomFloat(0.5, 1.0);
                
                const x1 = randomInt(0, size);
                const y1 = randomInt(0, size);
                const x2 = randomInt(0, size);
                const y2 = randomInt(0, size);
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // æ·»åŠ å‘å…‰æ•ˆæœ
                ctx.shadowBlur = 10;
                ctx.shadowColor = color;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            // ç”Ÿæˆå‡ ä½•å›¾å½¢ï¼ˆå¸¦éœ“è™¹æ•ˆæœï¼‰
            const shapeCount = randomInt(5, 12);
            for (let i = 0; i < shapeCount; i++) {
                const shapeType = randomInt(0, 3);
                const x = randomInt(50, size - 50);
                const y = randomInt(50, size - 50);
                const sizeShape = randomInt(40, 120);
                const color = randomCyberColor();
                
                ctx.globalAlpha = randomFloat(0.4, 0.8);
                ctx.fillStyle = color;
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                
                switch(shapeType) {
                    case 0: // åœ†å½¢
                        ctx.beginPath();
                        ctx.arc(x, y, sizeShape / 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        break;
                    case 1: // çŸ©å½¢
                        ctx.fillRect(x - sizeShape / 2, y - sizeShape / 2, sizeShape, sizeShape);
                        ctx.strokeRect(x - sizeShape / 2, y - sizeShape / 2, sizeShape, sizeShape);
                        break;
                    case 2: // ä¸‰è§’å½¢
                        ctx.beginPath();
                        ctx.moveTo(x, y - sizeShape / 2);
                        ctx.lineTo(x - sizeShape / 2, y + sizeShape / 2);
                        ctx.lineTo(x + sizeShape / 2, y + sizeShape / 2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;
                    case 3: // å…­è¾¹å½¢
                        ctx.beginPath();
                        for (let j = 0; j < 6; j++) {
                            const angle = (Math.PI / 3) * j;
                            const px = x + (sizeShape / 2) * Math.cos(angle);
                            const py = y + (sizeShape / 2) * Math.sin(angle);
                            if (j === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;
                }
            }
            
            // é‡ç½®é€æ˜åº¦
            ctx.globalAlpha = 1.0;
            
            // æ·»åŠ æ•°æ®æµæ•ˆæœï¼ˆå‚ç›´çº¿æ¡ï¼‰
            const dataStreamCount = randomInt(3, 6);
            for (let i = 0; i < dataStreamCount; i++) {
                const x = randomInt(0, size);
                const color = randomCyberColor();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6;
                
                const segments = randomInt(3, 8);
                let currentY = 0;
                for (let j = 0; j < segments; j++) {
                    const segmentHeight = randomInt(20, 80);
                    ctx.beginPath();
                    ctx.moveTo(x, currentY);
                    ctx.lineTo(x, currentY + segmentHeight);
                    ctx.stroke();
                    currentY += segmentHeight + randomInt(10, 30);
                    if (currentY > size) break;
                }
            }
            
            // æ·»åŠ éšæœºå…‰ç‚¹
            const dotCount = randomInt(10, 20);
            for (let i = 0; i < dotCount; i++) {
                const x = randomInt(0, size);
                const y = randomInt(0, size);
                const color = randomCyberColor();
                const radius = randomInt(2, 6);
                
                ctx.fillStyle = color;
                ctx.globalAlpha = randomFloat(0.6, 1.0);
                ctx.shadowBlur = 10;
                ctx.shadowColor = color;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            ctx.globalAlpha = 1.0;
            
            document.getElementById('status').innerHTML = '<p style="color: #00ff88;">âœ“ éšæœºå›¾ç‰‡å·²ç”Ÿæˆï¼ç°åœ¨å¯ä»¥åˆ‡åˆ†å¹¶ä¸‹è½½ã€‚</p>';
        }
        
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }
            
            // æ£€æŸ¥æ–‡ä»¶ç±»å‹
            if (!file.type.startsWith('image/')) {
                document.getElementById('status').innerHTML = '<p style="color: #ff00ff;">âœ— è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼</p>';
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const size = 600;
                    
                    // æ¸…ç©ºç”»å¸ƒï¼Œä½¿ç”¨æ·±è‰²èƒŒæ™¯
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(0, 0, size, size);
                    
                    // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼Œä¿æŒå›¾ç‰‡æ¯”ä¾‹å¹¶å¡«å……æ•´ä¸ªcanvas
                    const scale = Math.max(size / img.width, size / img.height);
                    const scaledWidth = img.width * scale;
                    const scaledHeight = img.height * scale;
                    
                    // å±…ä¸­ç»˜åˆ¶å›¾ç‰‡
                    const x = (size - scaledWidth) / 2;
                    const y = (size - scaledHeight) / 2;
                    
                    ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                    
                    document.getElementById('status').innerHTML = '<p style="color: #00ff88;">âœ“ å›¾ç‰‡å·²ä¸Šä¼ å¹¶åŠ è½½ï¼ç°åœ¨å¯ä»¥åˆ‡åˆ†å¹¶ä¸‹è½½ã€‚</p>';
                };
                img.onerror = function() {
                    document.getElementById('status').innerHTML = '<p style="color: #ff00ff;">âœ— å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·é‡è¯•ï¼</p>';
                };
                img.src = e.target.result;
            };
            reader.onerror = function() {
                document.getElementById('status').innerHTML = '<p style="color: #ff00ff;">âœ— æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•ï¼</p>';
            };
            reader.readAsDataURL(file);
        }
        
        function splitAndDownload() {
            const size = 600;
            const cellSize = size / 3;
            
            // æ£€æŸ¥canvasæ˜¯å¦æœ‰å†…å®¹
            const imageData = ctx.getImageData(0, 0, size, size);
            let hasContent = false;
            for (let i = 0; i < imageData.data.length; i += 4) {
                if (imageData.data[i + 3] > 0) { // æ£€æŸ¥alphaé€šé“
                    hasContent = true;
                    break;
                }
            }
            
            if (!hasContent) {
                document.getElementById('status').innerHTML = '<p style="color: #ff00ff;">âœ— è¯·å…ˆä¸Šä¼ å›¾ç‰‡æˆ–ç”Ÿæˆå›¾ç‰‡ï¼</p>';
                return;
            }
            
            // åˆ›å»ºä¸´æ—¶canvasç”¨äºåˆ‡åˆ†
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = cellSize;
            tempCanvas.height = cellSize;
            const tempCtx = tempCanvas.getContext('2d');
            
            // åˆ‡åˆ†å¹¶ä¸‹è½½
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const partNum = row * 3 + col + 1;
                    const x = col * cellSize;
                    const y = row * cellSize;
                    
                    // æ¸…ç©ºä¸´æ—¶canvas
                    tempCtx.clearRect(0, 0, cellSize, cellSize);
                    
                    // å¤åˆ¶å¯¹åº”åŒºåŸŸ
                    tempCtx.drawImage(
                        canvas,
                        x, y, cellSize, cellSize,
                        0, 0, cellSize, cellSize
                    );
                    
                    // è½¬æ¢ä¸ºblobå¹¶ä¸‹è½½
                    tempCanvas.toBlob(function(blob) {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `grid-part-${partNum}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    }, 'image/png');
                }
            }
            
            document.getElementById('status').innerHTML = '<p style="color: #00ff88;">âœ“ å·²å¼€å§‹ä¸‹è½½9ä¸ªå›¾ç‰‡æ–‡ä»¶ï¼è¯·æ£€æŸ¥æ‚¨çš„ä¸‹è½½æ–‡ä»¶å¤¹ã€‚</p>';
        }
    </script>
</body>
</html>

